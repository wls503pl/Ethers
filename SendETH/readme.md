In this lecture, we will introduce the Signer class and its derived Wallet class, and use it to send ETH.

## Signer Class

**Web3.js** assumes that users will deploy Ethereum nodes locally, and private keys and network connection status are managed by this node (this is not the case in reality);
in **ethers.js**, the **Provider** class manages the network connection status, and the **Signer** class or **Wallet** class manages the keys, which is safe and flexible.

In **ethers**, the **Signer** class is an abstraction of an Ethereum account, which can be used to sign messages and transactions, send signed transactions to the Ethereum network, and change the blockchain state.
The Signer class is an abstract class and cannot be instantiated directly. We need to use its subclass: the **Wallet** class.

## Wallet Class

The **Wallet** class inherits the **Signer** class and developers can use it to sign transactions and messages just like an Externally Owned Account (EOA) that contains a private key.<br>
There are several ways to create a Wallet instance:

- **Method 1**: Create a random wallet object
We can use the ***ethers.Wallet.createRandom()*** function to create a Wallet object with a random private key. The private key is generated by a cryptographically secure entropy source(If the current environment has no secure entropy source, an error is raised).
```
// Create Random Wallet Object
const wallet1 = ethers.Wallet.createRandom()
```

- **Method 2**: Create a wallet object using the private key
When the private key is known, the Wallet object can be created using the ethers.Wallet() function.
```
// Create a wallet object using the private key and provider
const privateKey = '0x227dbb8586117d55284e26620bc76534dfbd2394be34cf4a09cb775d593b6f2b'
const wallet2 = new ethers.Wallet(privateKey, provider)
```

- **Method 3**: Create a wallet object from a mnemonic
If you know the mnemonic, you can use the ethers.Wallet.fromPhrase() function to create a Wallet object.
```
// Create a wallet object from the mnemonic
const wallet3 = ethers.Wallet.fromPhrase(mnemonic.phrase)
```

<hr>

# Send ETH

To use the Wallet instance to send ETH, firstly, we need to construct a transaction request, in which we declare the receiving address **to** and the amount of ETH to be sent **value**.
The transaction request type **TransactionRequest** can contain information such as the sender **from**, **nonce**, request **data**, etc.

```
// Create a transaction request, parameters: to is the receiving address, value is the ETH amount
const tx = {
  to: address1,
  value: ethers.parseEther("0.001")
}
```

Then, we can use sendTransaction of the Wallet class to send the transaction, wait for the transaction to be on the chain, and get the transaction receipt. It is very simple.

```
// Send transaction, get a receipt
const txRes = await wallet2.sendTransaction(tx)
const receipt = await txRes.wait()      // Waiting for transaction confirmation on the chain
console.log(receipt)                    // Print a receipt for the transaction
```

## Code Sample

1. Creating a Provider Instance

```
// import ethers package
import { ethers } from "ethers";

// Use Alchemy's rpc node to connect to the Ethereum test network
// Available at https://chainlist.org
const ALCHEMY_SEPOLIA_URL = 'https://ethereum-sepolia-rpc.publicnode.com';
const provider = new ethers.JsonRpcProvider(ALCHEMY_SEPOLIA_URL);
```

2. Create a **Wallet** instance using three different methods
- Create a **Wallet** object with a random private key. The wallet created by this method is standalone, and we need to use the ***connect(provider)*** function to connect to the Ethereum node.
  The wallet created by this method can use  **mnemonic** to obtain mnemonic words.
  
```
// Create a random wallet object
const wallet1 = ethers.Wallet.createRandom()
const wallet1WithProvider = wallet1.connect(provider)
const mnemonic = wallet1.mnemonic      // Get the mnemonic
```

- Create a **Wallet** object using a private key and a **Provider** instance. The wallet created in this way cannot obtain the mnemonic phrase.

```
// Create a wallet object using the private key and provider
const privateKey = '0x227dbb8586117d55284e26620bc76534dfbd2394be34cf4a09cb775d593b6f2b'
const wallet2 = new ethers.Wallet(privateKey, provider)
```

- Create a **Wallet** object using the mnemonic. Here we use the mnemonic of wallet1, so the private key and public key of the created wallet are the same as those of wallet1.

```
// Create a wallet object from the mnemonic
const wallet3 = ethers.Wallet.fromPhrase(mnemonic.phrase)
```

3. Get the wallet address
Use the ***getAddress()*** function to get the wallet address

```
const address1 = await wallet1.getAddress()
const address2 = await wallet2.getAddress() 
const address3 = await wallet3.getAddress()

console.log(`1. Get wallet address`);
console.log(`Wallet 1 address: ${address1}`);
console.log(`Wallet 2 address: ${address2}`);
console.log(`Wallet 3 address: ${address3}`);
console.log(`Are the addresses of wallet 1 and wallet 3 the same: ${address1 === address3}`);
```

![getWalletAddress](https://github.com/wls503pl/Ethers/blob/main/SendETH/img/getWalletAddress.png)<br><br>

4. Get mnemonic phrase
Use the **mnemonic.phrase** member of the wallet object to get the mnemonic phrase:

```
console.log(`Wallet1 mnemonic: ${wallet1.mnemonic.phrase}`)
```

![getMnemonic](https://github.com/wls503pl/Ethers/blob/main/SendETH/img/getMnemonic.png)<br><br>

5. Get the private key
Use the privateKey member of the wallet object to obtain the private key:

```
console.log(`Wallet2 private key: ${wallet2.privateKey}`)
```

![getPrivateKey](https://github.com/wls503pl/Ethers/blob/main/SendETH/img/getPrivateKey.png)<br><br>

6. Get the number of wallet interactions on the chain
Use the ***getTransactionCount()*** function to obtain the number of wallet interactions on the chain

```
const txCount1 = await provider.getTransactionCount(wallet1WithProvider)
const txCount2 = await provider.getTransactionCount(wallet2)
console.log(`Number of transactions sent by wallet 1: ${txCount1}`)
console.log(`Number of transactions sent by wallet 2: ${txCount2}`)
```

![getTransactionNumberOnChain](https://github.com/wls503pl/Ethers/blob/main/SendETH/img/getTransactionNumberOnChain.png)<br><br>

7. Send ETH
Use wallet2 to send 0.001 ETH to wallet1, and print the wallet balance before and after the transaction. Since wallet1 is a newly created random private key wallet, the balance before the transaction is 0, and the balance after the transaction is 0.001 ETH.

```
// send ETH
// If this wallet has no goerli testnet ETH, go to the faucet to get some, wallet address: 0xe16C1623c1AA7D919cd2241d8b36d9E79C1Be2A2
// Chainlink Faucets: https://faucets.chain.link/
console.log(`\n5. Send ETH (test network)`);

// i. Print the balance before the transaction
console.log(`i. Balance before sending`)
console.log(`Wallet1: ${ethers.formatEther(await provider.getBalance(wallet1WithProvider))} ETH`)
console.log(`Wallet2: ${ethers.formatEther(await provider.getBalance(wallet2))} ETH`)

// ii. Construct a transaction request, parameters: to is the receiving address, value is the ETH amount
const tx = {
  to: address1,
  value: ethers.parseEther("0.001")
}

// iii. Send transaction and get receipt
console.log(`\nii. Waiting for the transaction to be confirmed in the blockchain (it takes a few minutes)`)
const receipt = await wallet2.sendTransaction(tx)
await receipt.wait()      // Wait for transaction confirmation on the chain
console.log(receipt)      // Print transaction details

// iv. Print the balance after the transaction
console.log(`\niii. Balance after sending`)
console.log(`Wallet1: ${ethers.formatEther(await provider.getBalance(wallet1WithProvider))} ETH`)
console.log(`Wallet2: ${ethers.formatEther(await provider.getBalance(wallet2))} ETH`)
```

<hr>

# At Last
I can't get enough ETH on Test Net, so the result of the transaction is as follows:<br>

![notEnoughFunds](https://github.com/wls503pl/Ethers/blob/main/SendETH/img/notEnoughFunds.png)
